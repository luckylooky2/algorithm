// 암호코드 : 동적 계획법
const string = require("fs").readFileSync(0, "utf-8").toString().trim();
const n = string.length;
const dp = new Array(n + 1).fill(1);
let flag = false;

loop: for (let i = 2; i <= n; i++) {
  const [prevChar, currChar] = [string[i - 2], string[i - 1]];
  const [_prevNum, currNum] = [+prevChar, +currChar];
  const lastTwoDigit = +(prevChar + currChar);
  if (currNum === 0) {
    dp[i - 1] = 0;
  }
  if (lastTwoDigit > 26) {
    dp[i - 2] = 0;
  } else if (lastTwoDigit === 0) {
    flag = true;
    break loop;
  }
  dp[i] = (dp[i - 1] + dp[i - 2]) % 1000000;
}

if (+string[0] === 0) {
  flag = true;
}

console.log(flag ? 0 : dp[n]);

// 백트래킹은 안 됨
// 알약 문제는 카탈란 수?

// 각 숫자들 사이를 끊을 수 있는 방법의 수
// => 세 자리 이상은 못 끊음. 5자리라면 Math.floor(5 / 2) => 최소 2개 ~ 4개. 조합으로?
// => 1, 2로 만들 수 있는 개수
// => 자리수(n)를 1, 2의 합으로 만들 수 있는 개수

// 총 경우의 수
// 1(1) => 1
// 2(2) => 1, 1 / 2
// 3(3) => 1, 1, 1 / 1, 2 / 2, 1
// 4(5) => 1, 1, 1, 1 /  1, 1, 2 / 1, 2, 1 / 2, 1, 1 / 2, 2
// 5(8) => 1, 1, 1, 1, 1 / 1, 2, 2 / 2, 1, 2 / 2, 2, 1 / 1, 1, 1, 2 / 1, 1, 2, 1 / 1, 2, 1, 1 / 2, 1, 1, 1
// 6(13) => 1, 1, 1, 1, 1, 1 / 1, 1, 1, 1, 2 ~ 2, 1, 1, 1, 1(5) / 1, 1, 2, 2 ~ 2, 2, 1, 1(6) / 2, 2, 2
// => 피보나치 수열
// n - 1의 경우에 1을 붙이고, n - 2의 경우에는 2를 붙이면 되기 때문

// 15151
// 1(1) => 1
// 2(2) => 1, 1 / 2
// 3(2) => 1, 1, 1 / 2, 1
// 4(4) => 1, 1, 1, 1 / 1, 1, 2 / 2, 1, 1 / 2, 2
// 5(4) => 1, 1, 1, 1, 1 / 2, 2, 1 / 1, 1, 2, 1 / 2, 1, 1, 1

// 25
// - 1(1) => 1
// - 2(2) => 1, 1 / 2

// 251
// - 1(1) => 1
// - 2(2) => 1, 1 / 2
// - 3(2) => 1, 1, 1 / 2, 1

// 조건 1: 가장 뒷 두 자리 수가 26을 넘으면, dp[i - 2]의 경우의 수는 버림

// 0의 존재: 10, 100, 101, 0101 등 ...
// 조건 2: 가장 뒷 자리 수가 0이면, dp[i - 1]의 경우의 수는 버림
// - 한 자리를 더하는 경우의 수는 이제 의미가 없기 때문에, dp[i - 1] = 0
// - 이제부터는 두 자리를 더하는 경우의 수만 의미가 있음

// 조건 3: 가장 뒷 두 자리 수가 0이라면, 루프 종료
// - 0이 연속 두 번 나오는 경우는 한 자리로도 두 자리로도 처리할 수 없는 해석할 수 없으므로 루프를 종료
