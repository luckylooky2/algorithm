// 하노이 탑 : 재귀, 분할 정복
const n = +require("fs").readFileSync(0, "utf-8").trim();
const trace = [];

function recur(from, to, num) {
  if (num === 1) {
    trace.push([from, to]);
    return;
  }

  // 1) n - 1개를 1 -> 2
  recur(from, 6 - from - to, num - 1);
  // 2) 1개를 1 -> 3
  recur(from, to, 1);
  // 3) n - 1개를 2 -> 3
  recur(6 - from - to, to, num - 1);
}

let answer = 1n;

for (let i = 0; i < n; i++) {
  answer = answer * 2n;
}

console.log(String(answer - 1n));

if (n <= 20) {
  recur(1, 3, n);
  console.log(trace.map((v) => v.join(" ")).join("\n"));
}

// 1, 2, 3
// 6 - n - m ?
// n - 1개를 하나로, 1개를 나머지로

// Try 1
// - n - 1개를 1 -> 2, 1개를 1 -> 3로 옮긴다는 것까지는 기억해냈는데, 마지막을 빼먹었다
// - n - 1개를 2 -> 3으로 보내야 전체를 1 -> 3으로 보낼 수 있음

// Try 2 : 분할 정복
// n개를 1 -> 3으로 보내는 것은 아래와 같은 과정을 재귀적으로 실행하면 된다
// - 1) n - 1개를 1 -> 2로 보내고
// - 2) 1개를 1 -> 3으로 보내고
// - 3) n - 1개를 2 -> 3으로 보내는 과정

// - Math.max()는 BigInt 연산이 아님에 주의

// - 전체 경우의 수는 동적 계획법으로 구하는 것이 아니라 바닥 조건에서 일일이 세는 것이기 때문에, n이 커지는 경우 시간 초과가 발생
// - 일반항을 구하여 n이 20 이상인 수에 대해서는 재귀를 호출하면 안 된다

// 일반항(n번째 항의 옮기는 총 횟수)
// - n = 1: 1(1 -> 3) = 1
// - n = 2: 1(1개를 1 -> 2) + 1(1개를 2 -> 3) + 1(1 -> 3) = 3
// - n = 3: 3(2개를 1 -> 2) + 3(2개를 2 -> 3) + 1(1 -> 3) = 7
// - n = 4: 7(3개를 1 -> 2) + 7(3개를 2 -> 3) + 1(1 -> 3) = 15
// - 점화식: an = a(n - 1) * 2 + 1
// - 일반항: an = a1 * r^n - 1 = 2^n - 1
